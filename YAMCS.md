# Using Yamcs for Fli3d

## Introduction

Fli3d is a small ESP32-based payload developed for fun.  It is designed to be put on-board a microrocket, which is due to reach an altitude of about 100m.  The payload will perform measurements during the flight (images, gps, accelerometer/gyrometer, barometer), will store these on an SD, and also transmit the data to ground in real-time over WiFi and over 433 MHz radio.

More information about fli3d can be found here: https://github.com/jmwislez/fli3d/.

For receiving, monitoring, displaying and storing the real-time data, I was looking for the appropriate software.  Yamcs seemed especially suited, since it is designed to do exactly this, only for real space systems.

This page discusses how I configured Yamcs for this purpose.

## Telemetry format

Originally, the telemetry generated by the ESP32 was based on JSON messages, transmitted directly over UDP, or via a MQTT server.  While this is very convenient to implement and use for logging and debugging, it is of course inefficient in its use of bandwidth, which may become an issue when the rocket is getting high and the WiFi connection bad.  Also, Yamcs at this stage does not work with JSON or MQTT out of the box, so I quickly decided to take the benefit of the constraint and to transmit the telemetry as compact CCSDS packages to a TCP port, the latter to ensure error correction when the connection worsens. 

## Sending telemetry packets from ESP32

The excerpts of Arduino code below illustrates how to send a CCSDS telemetry packet over UDP, containing the content of a struct as data payload.  Functional code is in https://github.com/jmwislez/fli3d_lib

```c++
struct __attribute__ ((packed)) ccsds_hdr_t {
  uint8_t  apid_H:3;                // 0:5
  bool     sec_hdr:1;               // 0: 4
  bool     type:1;                  // 0:  3
  uint8_t  version:3;               // 0:   0
  uint8_t  apid_L;                  // 1
  uint8_t  seq_ctr_H:6;             // 2:2
  uint8_t  seq_flag:2;              // 2: 0
  uint8_t  seq_ctr_L;               // 3
  uint8_t  pkt_len_H;               // 4
  uint8_t  pkt_len_L;               // 5
} ccsds_hdr;

struct __attribute__ ((packed)) ccsds_t {
  char     ccsds_hdr[6];
  char     blob[TM_MAX_MSG_SIZE];
  uint8_t  blob_size;
} ccsds_buffer;

void ccsds_publish (char* payload_ptr, uint16_t payload_len) {
  update_ccsds_hdr (PID, PKT_TM, payload_len);
  memcpy (&ccsds_buffer.ccsds_hdr, &ccsds_hdr, sizeof (ccsds_hdr_t));
  memcpy (&ccsds_buffer.blob, payload_ptr, payload_len);
  ccsds_buffer->blob_size = sizeof(ccsds_hdr_t) + payload_len;  
  yamcs_publish (&ccsds_buffer);
}

void update_ccsds_hdr (uint16_t PID, bool pkt_type, uint16_t pkt_len) {
  static uint16_t ccsds_ctr[NUMBER_OF_PID];
  ccsds_ctr[PID]++;
  ccsds_hdr.version = 0;
  ccsds_hdr.type = pkt_type;
  ccsds_hdr.sec_hdr = false;
  ccsds_hdr.apid_H = (uint8_t)((PID + 42) >> 8);
  ccsds_hdr.apid_L = (uint8_t)(PID + 42);
  ccsds_hdr.seq_flag = 3;
  ccsds_hdr.seq_ctr_H = (uint8_t)(ccsds_ctr[PID] >> 8);
  ccsds_hdr.seq_ctr_L = (uint8_t)ccsds_ctr[PID];
  ccsds_hdr.pkt_len_H = (uint8_t)((pkt_len - 1) >> 8);
  ccsds_hdr.pkt_len_L = (uint8_t)(pkt_len - 1);
}

void yamcs_publish (ccsds_t* ccsds_buffer) { 
  wifiUDP.beginPacket(yamcs_server, yamcs_tm_port);
  wifiUDP.write ((const uint8_t*)&ccsds_buffer->blob, ccsds_buffer->blob_size);
  wifiUDP.endPacket();
}
```
The CCSDS format is described in https://public.ccsds.org/Pubs/133x0b1c2.pdf. 

## Setting up Yamcs

I installed Yamcs on a Ubuntu 16.04 computer, following the instructions on https://yamcs.org/getting-started.  After ensuring it works with the provided example, I started tuning this example to my system.  

This is what I needed to adapt to start:
 - Updated ```src/main/yamcs/etc/yamcs.yaml```  
 - Created ```src/main/yamcs/etc/yamcs.fli3d.yaml``` based on ```yamcs.myproject.yaml```
 - Created ```src/main/yamcs/mdb/xtce.fli3d.mdb``` based on ```xtce.mdb```, and reworked it to define my telemetry test packet (pretty straightforward for basic stuff).
All three these files are found in https://github.com/jmwislez/fli3d/tree/master/Yamcs/yamcs-server

Re-starting Yamcs, I got parsing and compiling errors and warnings for the ```xtce.fli3d.mdb``` file until I got it right.  Nice!  After that, as a charm my telemetry was visible in the Yamcs web application!

In order to set up the latest Yamcs server instead of the demo version, install the precompiled package from https://github.com/yamcs/yamcs/releases.  Copy your configuration files to ```etc/``` and ```mdb/```, and you're done.

With this initial end-to-end test in place, I could further extend this, to implement all the functionality I need:
 - setting up and configuring Yamcs Studio for synoptic displays
 - adding multiple packets and improving the MDB
 - setting up the packet viewer 
 - adding event packets
 - moving to TCP
 - introducing telecommands
 - introducing archiving

## Setting up Yamcs Studio

I first tried by downloading Yamcs Studio from github (https://github.com/yamcs/yamcs-studio), unzipping it, and compiling it using the “make” command, just as explained on github.  From there, I consulted the documentation in https://yamcs.org/media/yamcs-studio.pdf, but could not get any further.  The next step was impossible to guess: starting Yamcs Studio goes by the following command:
```releng/org.yamcs.studio.editor.product/target/products/yamcs-studio/linux/gtk/x86_64/yamcs-studio-1.3.4-SNAPSHOT/Yamcs\ Studio```

While getting this answer from the developers, I got the advise to rather get a precompiled version from https://github.com/yamcs/yamcs-studio/releases .  That was much easier, indeed.

Some interesting windows like “Archive” and “Data Links” are not activated by default, so this needs to be done first through "Windows" / "Show View" / "Others...". 

The learning curve for creating synoptic displays with the Display Builder is not steep.  The interface has some glitches and pecularities, but these are easily worked around once known.  It is also very easy to have both Display Builder and Display Runner open, as this allows to test changes in displays immediately.

The displays I created for Fli3d are here: https://github.com/jmwislez/fli3d/tree/master/Yamcs/yamcs-studio

## Adding multiple packets and improving the Mission Database

This was easy: I just had to have my payload send different packets over different APIDs, and define these packets in ```xtce.fli3d.xml```.

Further editing of the ```src/main/yamcs/mdb/xtce.fli3d.xml``` MDB definition file can be done following the format description in https://public.ccsds.org/Pubs/660x1g1.pdf. Be sure to edit the file in src, and not the file in target as I accidentally did a few times.  It happened to me by accident and I lost my updates.  Additions are:
  - add measurement units
  - add enumeration labels
  - define correct endianness of multi-byte data.  In the XTCE file, uint16_t should be defined as ```<IntegerDataEncoding encoding="unsigned" sizeInBits="16" byteOrder="leastSignificantByteFirst" />``` to correctly interpret data encoded by ESP32.

Note that if you define a series of sub-byte elements in the packed struct on the ESP32, these are interpreted in reversed sequence on Yamcs.  

## Setting up the Packet Viewer

The best way to get the Packet Viewer is from the Yamcs release page: https://github.com/yamcs/yamcs/releases

I personally did not yet manage to get it to work.  I did not put much effort on it, as there is a rudimentary packet viewer in the Yamcs Server web interface, which was sufficient to support my debugging work.

## Adding Event packets

## Moving to TCP

## Introducing telecommanding

## Introducing archiving


