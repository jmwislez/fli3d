# Using Yamcs for Fli3d

## Introduction

Fli3d is a small ESP32-based payload developed for fun.  It is designed to be put on-board a microrocket, which is due to reach an altitude of about 100m.  The payload will perform measurements during the flight (images, gps, accelerometer/gyrometer, barometer), will store these on an SD, and also transmit the data to ground in real-time over WiFi and over 433 MHz radio.

More information about fli3d can be found here: https://github.com/jmwislez/fli3d/.

For receiving, monitoring, displaying and storing the real-time data, I was looking for the appropriate software.  Yamcs seemed especially suited, since it is designed to do exactly this, only for real space systems.

This page discusses how I configured Yamcs for this purpose.

## Telemetry format

Originally, the telemetry generated by the ESP32 was based on JSON messages, transmitted directly over UDP, or via a MQTT server.  While this is very convenient to implement and use for logging and debugging, it is of course inefficient in its use of bandwidth, which may become an issue when the rocket is getting high and the WiFi connection bad.  Also, Yamcs at this stage does not work with JSON or MQTT out of the box, so I quickly decided to take the benefit of the constraint and to transmit the telemetry as compact CCSDS packages to a TCP port, the latter to ensure error correction when the connection worsens. 

## Sending telemetry packets from ESP32

The excerpts of Arduino code below illustrates how to send a CCSDS telemetry packet over UDP, containing the content of a struct as data payload.  Functional code is in https://github.com/jmwislez/fli3d-lib

```c++
struct __attribute__ ((packed)) ccsds_hdr_t {
  uint8_t  apid_H:3;                // 0:5
  bool     sec_hdr:1;               // 0: 4
  bool     type:1;                  // 0:  3
  uint8_t  version:3;               // 0:   0
  uint8_t  apid_L;                  // 1
  uint8_t  seq_ctr_H:6;             // 2:2
  uint8_t  seq_flag:2;              // 2: 0
  uint8_t  seq_ctr_L;               // 3
  uint8_t  pkt_len_H;               // 4
  uint8_t  pkt_len_L;               // 5
} ccsds_hdr;

struct __attribute__ ((packed)) ccsds_t {
  char     ccsds_hdr[6];
  char     blob[TM_MAX_MSG_SIZE];
  uint8_t  blob_size;
} ccsds_buffer;

void ccsds_publish (char* payload_ptr, uint16_t payload_len) {
  update_ccsds_hdr (PID, PKT_TM, payload_len);
  memcpy (&ccsds_buffer.ccsds_hdr, &ccsds_hdr, sizeof (ccsds_hdr_t));
  memcpy (&ccsds_buffer.blob, payload_ptr, payload_len);
  ccsds_buffer->blob_size = sizeof(ccsds_hdr_t) + payload_len;  
  yamcs_publish (&ccsds_buffer);
}

void update_ccsds_hdr (uint16_t PID, bool pkt_type, uint16_t pkt_len) {
  static uint16_t ccsds_ctr[NUMBER_OF_PID];
  ccsds_ctr[PID]++;
  ccsds_hdr.version = 0;
  ccsds_hdr.type = pkt_type;
  ccsds_hdr.sec_hdr = false;
  ccsds_hdr.apid_H = (uint8_t)((PID + 42) >> 8);
  ccsds_hdr.apid_L = (uint8_t)(PID + 42);
  ccsds_hdr.seq_flag = 3;
  ccsds_hdr.seq_ctr_H = (uint8_t)(ccsds_ctr[PID] >> 8);
  ccsds_hdr.seq_ctr_L = (uint8_t)ccsds_ctr[PID];
  ccsds_hdr.pkt_len_H = (uint8_t)((pkt_len - 1) >> 8);
  ccsds_hdr.pkt_len_L = (uint8_t)(pkt_len - 1);
}

void yamcs_publish (ccsds_t* ccsds_buffer) { 
  wifiUDP.beginPacket(yamcs_server, yamcs_tm_port);
  wifiUDP.write ((const uint8_t*)&ccsds_buffer->blob, ccsds_buffer->blob_size);
  wifiUDP.endPacket();
}
```
The CCSDS format is described in https://public.ccsds.org/Pubs/133x0b1c2.pdf. 

## Setting up Yamcs

I installed Yamcs on a Ubuntu 16.04 computer, following the instructions on https://yamcs.org/getting-started.  After ensuring it works with the provided example, I started tuning this example to my system.  

This is what I needed to adapt to start:
 - Updated ```src/main/yamcs/etc/yamcs.yaml```  
 - Created ```src/main/yamcs/etc/yamcs.fli3d.yaml``` based on ```yamcs.myproject.yaml```
 - Created ```src/main/yamcs/mdb/xtce.fli3d.mdb``` based on ```xtce.mdb```, and reworked it to define my telemetry test packet (pretty straightforward for basic stuff).
All three these files are found in https://github.com/jmwislez/fli3d/tree/master/Yamcs/yamcs-server

Re-starting Yamcs, I got parsing and compiling errors and warnings for the ```xtce.fli3d.mdb``` file until I got it right.  Nice!  After that, as a charm my telemetry was visible in the Yamcs web application!

With this initial end-to-end test in place, I could further extend this, to implement all the functionality I need:
 - setting up and configuring Yamcs Studio for synoptic displays
 - add multiple packets
 - [move to TCP
 - [add event packets
 - [using the packet viewer: not really needed: there is a rudimentary one in Yamcs Server 
 - [telecommands
 - [archiving

## Setting up Yamcs Studio

I first tried by downloading Yamcs Studio from github (https://github.com/yamcs/yamcs-studio), unzipping it, and compiling it using the “make” command, just as explained on github.  From there, I consulted the documentation in https://yamcs.org/media/yamcs-studio.pdf, but could not get any further.  The next step was impossible to guess: starting Yamcs Studio goes by the following command:
```releng/org.yamcs.studio.editor.product/target/products/yamcs-studio/linux/gtk/x86_64/yamcs-studio-1.3.4-SNAPSHOT/Yamcs\ Studio```

While getting this answer from the developers, I got the advise to get a precompiled version from XXXXXXX

The interesting windows “Archive” and “Data Links” are not activated by default, so this needs to be done first through the XXXXX 

## Adding multiple packets

This was easy: I just had to have my payload send different packets over different APIDs, and define these packets in ```xtce.fli3d.xml```.

Further editing of the ```src/main/yamcs/mdb/xtce.fli3d.xml``` MDB definition file can be done following the format description in https://public.ccsds.org/Pubs/660x1g1.pdf. Be sure to edit the file in src, and not the file in target as I accidentally did a few times.  It happened to me by accident and I lost my updates.  Additions are:
  - add measurement units
  - add enumeration labels
  - define correct endianness of multi-byte data.  In the XTCE file, uint16_t should be defined as <IntegerDataEncoding encoding="unsigned" sizeInBits="16" byteOrder="leastSignificantByteFirst" /> to correctly interpret data encoded by ESP32.
reverse order of sub-byte elements



See mail of Fabian on using binary distributions. 


Things I observed:
Yamcs Server:
on the Yamcs Server webpage, in parameters, the TM/TC value of Type in CCSDS_Packet_ID shows as “false”, while in the xtce file, zeroStringValue="TM" and oneStringValue="TC" are defined.
Display Editor:
editing the “PV Name” property in the Properties tab does not show until enter is pressed, this is true for most of the entries there

Questions:
how to migrate from demo instance of yamcs to yamcs-master?


